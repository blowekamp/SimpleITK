{
  "name" : "LevelSetMotionRegistrationFilter",
  "template_code_filename" : "ImageFilter",
  "template_test_filename" : "ImageFilter",
  "no_procedure" : "1",
  "number_of_inputs" : 2,
  "pixel_types" : "RealPixelIDTypeList",
  "filter_type" : "itk::LevelSetMotionRegistrationFilter<InputImageType, InputImageType, itk::Image< Vector<float, InputImageType::ImageDimension>, InputImageType::ImageDimension > >",
  "custom_set_input" : "filter->SetFixedImage( image1 ); filter->SetMovingImage( image2 );",
  "members" : [
    {
      "name" : "GradientSmoothingStandardDeviations",
      "type" : "double",
      "default" : "1.0",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set/Get the standard deviation used for smoothing the moving image prior to calculating gradients. The standard deviation is measured in physical units (for instance mm). Note that this smoothing value is not to be confused with the PDEDeformableRegistrationFilter::SetStandardDeviations()method. The method in PDEDeformableRegistrationFilteris for setting the smoothing parameters for regularizing the deformation field between interations. Those smoothing parameters are set in pixel units not physical units. Deformation field smoothing is not done by default in LevelSetMotionRegistration. This smoothing parameter is to condition the gradient calculation and parameter is specified in physical units.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : ""
    },
    {
      "name" : "Alpha",
      "type" : "double",
      "default" : "0.1",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set/Get the parameter alpha. Alpha is added to the calculated gradient magnitude prior to normalizing the gradient to protect against numerical instability as the gradient magnitude approaches zero. This should be set as a small fraction of the intensity dynamic range, for instance 0.04%. Default is the absolute (not percentage) value of 0.1.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : ""
    },
    {
      "name" : "GradientMagnitudeThreshold",
      "type" : "double",
      "default" : "1e-9",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set/Get the threshold below which the gradient magnitude is considered the zero vector. Default is 1e-9.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : ""
    },
    {
      "name" : "SmoothDisplacementField",
      "type" : "bool",
      "default" : 0
    },
    {
      "name" : "StandardDeviations",
      "type" : "double",
      "dim_vec" : 1,
      "set_as_scalar" : 1,
      "default" : "std::vector<double>(3, 1.0)",
      "itk_type" : "typename FilterType::StandardDeviationsType"
    },
    {
      "name" : "UpdateFieldStandardDeviations",
      "type" : "double",
      "dim_vec" : 1,
      "set_as_scalar" : 1,
      "default" : "std::vector<double>(3, 1.0)",
      "itk_type" : "typename FilterType::StandardDeviationsType"
    },
    {
      "name" : "MaximumKernelWidth",
      "type" : "unsigned int",
      "default" : "30u"
    },
    {
      "name" : "MaximumError",
      "type" : "double",
      "default" : "0.1"
    },
    {
      "name" : "SmoothUpdateField",
      "type" : "bool",
      "default" : 0
    },
    {
      "name" : "IntensityDifferenceThreshold",
      "type" : "double",
      "default" : "0.001",
      "briefdescriptionSet" : "",
      "detaileddescriptionSet" : "Set/Get the threshold below which the absolute difference of intensity yields a match. When the intensities match between a moving and fixed image pixel, the update vector (for that iteration) will be the zero vector. Default is 0.001.\n",
      "briefdescriptionGet" : "",
      "detaileddescriptionGet" : ""
    },
    {
      "name" : "NumberOfIterations",
      "type" : "uint32_t",
      "default" : "5u",
      "doc" : "Number of iterations to run"
    },
    {
      "name" : "MaximumRMSError",
      "type" : "double",
      "default" : 0.02,
      "doc" : "Value of RMS change below which the filter should stop. This is a convergence criterion."
    },
    {
      "name" : "UseImageSpacing",
      "type" : "bool",
      "default" : 1
    }
  ],
  "measurements" : [
    {
      "name" : "ElapsedIterations",
      "type" : "uint32_t",
      "default" : 0,
      "briefdescriptionGet" : "Number of iterations run."
    },
    {
      "name" : "RMSChange",
      "type" : "double",
      "default" : 0.0,
      "briefdescriptionGet" : "The Root Mean Square of the levelset upon termination."
    },
    {
      "name" : "Metric",
      "type" : "double",
      "default" : 0.0,
      "briefdescriptionGet" : "Get the metric value",
      "detaileddescriptionGet" : "The metric value is the mean square difference in intensity between the fixed image and transforming moving image computed over the the overlapping region between the two images. This is value is only available for the previous iteration and NOT the current iteration."
    }
  ],
  "tests" : [],
  "briefdescription" : "Deformably register two images using level set motion.\n",
  "detaileddescription" : "LevelSetMotionFilter implements a deformable registration algorithm that aligns a fixed and a moving image under level set motion. The equations of motion are similar to those of the DemonsRegistrationFilter. The main differences are: (1) Gradients of the moving image are calculated on a smoothed image while intensity difference are measured on the original images (2) Magnitude of the motion vector is a function of the differences in intensity between the fixed and moving pixel. An adaptive timestep is calculated based on the maximum motion vector over the entire field to ensure stability. The timestep also implictly converts the motion vector measured in units of intensity to a vector measured in physical units. Demons, on the other hand, defines its motion vectors as function of both the intensity differences and gradient magnitude at each respective pixel. Consider two separate pixels with the same intensity differences between the corresponding fixed and moving pixel pairs. In demons, the motion vector of the pixel over a low gradient region will be larger than the motion vector of the pixel over a large gradient region. This leads to an unstable vector field. In the levelset approach, the motion vectors will be proportional to the gradients, scaled by the maximum gradient over the entire field. The pixel with at the lower gradient position will more less than the pixel at the higher gradient position. (3) Gradients are calculated using minmod finite difference instead of using central differences.\nA deformation field is represented as a image whose pixel type is some vector type with at least N elements, where N is the dimension of the fixed image. The vector type must support element access via operator []. It is assumed that the vector elements behave like floating point scalars.\nThis class is templated over the fixed image type, moving image type and the deformation field type.\nThe input fixed and moving images are set via methods SetFixedImage and SetMovingImage respectively. An initial deformation field maybe set via SetInitialDisplacementField or SetInput. If no initial field is set, a zero field is used as the initial condition.\nThe algorithm has one parameters: the number of iteration to be performed.\nThe output deformation field can be obtained via methods GetOutput or GetDisplacementField.\nThis class make use of the finite difference solver hierarchy. Update for each iteration is computed in LevelSetMotionFunction.\n\\warning This filter assumes that the fixed image type, moving image type and deformation field type all have the same number of dimensions.\nRef: B.C. Vemuri, J. Ye, Y. Chen, C.M. Leonard. \" Imageregistration via level-set motion: applications to atlas-based segmentation\". Medical ImageAnalysis. Vol. 7. pp. 1-20. 2003.\n\\see  LevelSetMotionRegistrationFunction\n\\see \n\\see  DemonsRegistrationFilter\n\n"
}
